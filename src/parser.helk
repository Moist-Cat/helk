# Formal grammar declaration for the HULK programming language
# Use "at sign" after every statement (yes, that includes comments).
# 
# Besides that, the syntax is like yacc's exept that we use
# the "dollar" symbol to separate the productions and the code.
#
# A few pointers:
# 
# - The code executes after the production is completely parsed
# - Each non-terminal returns a (ASTNode*) value called "node";
#    it defaults to NULL and you replace it with your own nodes.
# - There is a variable for each production
#    (named _{Production}; for example, if you have a non-terminal called
#    Expr, there will be a variable called _Expr in scope) already declared for you.
#    This variable contains the node (if it's a terminal) or the Token (it is not).
#    Use them to create complex structures
# - Don't forget to append "dollar" to the list of productions before writing code
# - Don't forget to write "at sign" after each statement

@

Program: StmtBlock $

    node = _StmtBlock;
    fprintf(stderr, "INFO - Created program block\n");

@

StmtBlock: Stmt SEMICOLON StmtBlockTail $

    // Collect all statements into a block
    if (_StmtBlockTail == NULL) {
        ASTNode** block = malloc(sizeof(ASTNode*) * 1);
        block[0] = _Stmt;
        node = create_ast_block(block, 1);
    } else {
        int count = _StmtBlockTail->block.stmt_count + 1;
        ASTNode** block = malloc(sizeof(ASTNode*) * count);
        block[0] = _Stmt;
        for (unsigned int i = 0; i < _StmtBlockTail->block.stmt_count; i++) {
            block[i+1] = _StmtBlockTail->block.statements[i];
        }
        node = create_ast_block(block, count);
        free(_StmtBlockTail->block.statements);
        free(_StmtBlockTail);
    }

@

StmtBlockTail: Stmt SEMICOLON StmtBlockTail $

    // Build linked list of statements
    if (_StmtBlockTail == NULL) {
        ASTNode** block = malloc(sizeof(ASTNode*) * 1);
        block[0] = _Stmt;
        node = create_ast_block(block, 1);
    } else {
        int count = _StmtBlockTail->block.stmt_count + 1;
        ASTNode** block = realloc(_StmtBlockTail->block.statements, sizeof(ASTNode*) * count);
        // Shift existing elements
        for (unsigned int i = count-1; i > 0; i--) {
            block[i] = block[i-1];
        }
        block[0] = _Stmt;
        node = create_ast_block(block, count);
    }

    | epsilon
@

Stmt: FunctionDef $
    node = _FunctionDef;

    | VariableDef $
    node = _VariableDef;

    | TypeDef $
    node = _TypeDef;

    | Expr $
    node = _Expr;
@

TypeDef: TYPE IDENTIFIER InheritsOpt LBRACE TypeMemberList RBRACE $

    char* parent = NULL;

    if (_InheritsOpt != NULL) {
        parent = _InheritsOpt->variable.name;
    }

    if (_TypeMemberList == NULL) {
        node = create_ast_type_def(_IDENTIFIER.value, parent, NULL, 0);
    } else {
        node = create_ast_type_def(_IDENTIFIER.value, parent, _TypeMemberList->block.statements, _TypeMemberList->block.stmt_count);
    }
    fprintf(stderr, "INFO - Created type: %s\n", _IDENTIFIER.value);
@

InheritsOpt: INHERITS IDENTIFIER $
    node = create_ast_variable(_IDENTIFIER.value);

    | epsilon
@

TypeMemberList: TypeMember SEMICOLON TypeMemberListTail $
    // Build member list in order
    int count = _TypeMemberListTail->block.stmt_count + 1;
    ASTNode** members = malloc(sizeof(ASTNode*) * count);
    members[0] = _TypeMember;
    for (unsigned int i = 0; i < _TypeMemberListTail->block.stmt_count; i++) {
        members[i+1] = _TypeMemberListTail->block.statements[i];
    }
    node = create_ast_block(members, count);
@

TypeMemberListTail: TypeMember SEMICOLON TypeMemberListTail $
    int count = _TypeMemberListTail->block.stmt_count + 1;
    ASTNode** members = malloc(sizeof(ASTNode*) * count);
    members[0] = _TypeMember;
    for (unsigned int i = 0; i < _TypeMemberListTail->block.stmt_count; i++) {
        members[i+1] = _TypeMemberListTail->block.statements[i];
    }
    node = create_ast_block(members, count);

    | epsilon $
        node = create_ast_block(NULL, 0);
@

TypeMember: FieldDef $
    node = _FieldDef;

    | MethodDef $
    node = _MethodDef;
@

FieldDef: IDENTIFIER EQUALS Expr $
    node = create_ast_field_def(_IDENTIFIER.value, _Expr);
    fprintf(stderr, "INFO - Created field: %s\n", _IDENTIFIER.value);
@

MethodDef: MEMBER IDENTIFIER LPAREN ParamList RPAREN ARROW Expr $
    // Prepend "self" to parameter list
    char** params = malloc(sizeof(char*) * (_ParamList->param_list.count + 1));
    params[0] = strdup("self");
    for (unsigned int i = 0; i < _ParamList->param_list.count; i++) {
        params[i+1] = _ParamList->param_list.params[i];
    }
    node = create_ast_function_def(_IDENTIFIER.value, _Expr, params, _ParamList->param_list.count + 1);
    fprintf(stderr, "INFO - Created method: %s\n", _IDENTIFIER.value);
@

FunctionDef: FUNCTION IDENTIFIER LPAREN ParamList RPAREN ARROW Expr $

    node = create_ast_function_def(_IDENTIFIER.value, _Expr, _ParamList->param_list.params, _ParamList->param_list.count);
    fprintf(stderr, "INFO - Created function: %s\n", _IDENTIFIER.value);

@

ParamList: epsilon $
    node = create_ast_param_list(NULL, 0);

    | IDENTIFIER ParamListTail $

    fprintf(stderr, "%p\n", _ParamListTail);
    char** params = malloc(sizeof(char*) * (_ParamListTail->param_list.count + 1));
    params[0] = _IDENTIFIER.value;
    for (unsigned int i = 0; i < _ParamListTail->param_list.count; i++) {
        params[i+1] = _ParamListTail->param_list.params[i];
    }
    node = create_ast_param_list(params, _ParamListTail->param_list.count + 1);
@

ParamListTail: COMMA IDENTIFIER ParamListTail $
    
    char** params = malloc(sizeof(char*) * (_ParamListTail->param_list.count + 1));
    params[0] = _IDENTIFIER.value;
    for (unsigned int i = 0; i < _ParamListTail->param_list.count; i++) {
        params[i+1] = _ParamListTail->param_list.params[i];
    }
    node = create_ast_param_list(params, _ParamListTail->param_list.count + 1);

    | epsilon $
        // this kode doesn't appear
        node = create_ast_param_list(NULL, 0);
@

VariableDef: LET IDENTIFIER EQUALS Expr $
    node = create_ast_variable_def(_IDENTIFIER.value, _Expr);
    fprintf(stderr, "INFO - Defined variable: %s\n", _IDENTIFIER.value);
@

Expr: Term ExprTail $

    if (_ExprTail == NULL) {
        node = _Term;
    } else {
        fprintf(stderr, "INFO - Completing Expr with type=%d\n", _Term->type);
        _ExprTail->binary_op.left = _Term;
        node = _ExprTail;
    }
@

ExprTail: PLUS Term ExprTail $
    if (_ExprTail == NULL) {
        node = create_ast_binary_op(NULL, _Term, OP_ADD);
    } else {
        node = create_ast_binary_op(
            NULL,
            create_ast_binary_op(_Term, _ExprTail, OP_ADD),
            OP_ADD
        );
    }

    | MINUS Term ExprTail $
    if (_ExprTail == NULL) {
        node = create_ast_binary_op(NULL, _Term, OP_SUB);
    } else {
        node = create_ast_binary_op(
            NULL,
            create_ast_binary_op(_Term, _ExprTail, OP_SUB),
            OP_ADD
        );
    }
    
    | epsilon
@

Term: Factor TermTail $
    if (_TermTail == NULL) {
        node = _Factor;
    } else {
        _TermTail->binary_op.left = _Factor;
        node = _TermTail;
    }
@

TermTail: MULTIPLY Factor TermTail $
    if (_TermTail == NULL) {
        node = create_ast_binary_op(NULL, _Factor, OP_MUL);
    } else {
        node = create_ast_binary_op(
            NULL,
            create_ast_binary_op(_Factor, _TermTail, OP_MUL),
            OP_MUL
        );
    }
    
    | DIVIDE Factor TermTail $
    if (_TermTail == NULL) {
        node = create_ast_binary_op(NULL, _Factor, OP_DIV);
    } else {
        node = create_ast_binary_op(
            NULL,
            create_ast_binary_op(_Factor, _TermTail, OP_DIV),
            OP_DIV
        );
    }
    
    | epsilon
@

Factor: NUMBER $
    node = create_ast_number(atoi(_NUMBER.value));

    | IDENTIFIER FactorTail $
    node = _FactorTail;
    if (node->type == AST_FUNCTION_CALL) {
        _FactorTail->function_call.name = _IDENTIFIER.value;
    }
    else {
        _FactorTail->variable.name = _IDENTIFIER.value;  // Set identifier name
    }

    | STRING_LITERAL $
    char* str = _STRING_LITERAL.value;
    size_t len = strlen(str);
    char* result = (char*) malloc(len - 1); // Total bytes: (len - 2) + 1
    memcpy(result, str + 1, len - 2); // Copy from index 1 to len-2
    result[len - 2] = '\0';

    node = create_ast_string(result);

    | LPAREN Expr RPAREN $
    node = _Expr;
@

FactorTail: LPAREN ArgList RPAREN $
    node = create_ast_function_call("", _ArgList->block.statements, _ArgList->block.stmt_count);
    // Identifier will be set in parent Factor

    | epsilon $
        node = create_ast_variable("");
@

ArgList: epsilon $
    node = create_ast_block(NULL, 0);

    | Expr ArgListTail $
    if (_ArgListTail == NULL) {
        ASTNode** args = malloc(sizeof(ASTNode*) * (1));
        args[0] = _Expr;
        node = create_ast_block(args, 1);
    }
    else {
        ASTNode** args = malloc(sizeof(ASTNode*) * (_ArgListTail->block.stmt_count + 1));
        args[0] = _Expr;
        for (unsigned int i = 0; i < _ArgListTail->block.stmt_count; i++) {
            args[i+1] = _ArgListTail->block.statements[i];
        }
        node = create_ast_block(args, _ArgListTail->block.stmt_count + 1);
    }
@

ArgListTail: COMMA Expr ArgListTail $
    ASTNode** args = malloc(sizeof(ASTNode*) * (_ArgListTail->block.stmt_count + 1));
    args[0] = _Expr;
    for (unsigned int i = 0; i < _ArgListTail->block.stmt_count; i++) {
        args[i+1] = _ArgListTail->block.statements[i];
    }
    node = create_ast_block(args, _ArgListTail->block.stmt_count + 1);

    | epsilon $
        node = create_ast_block(NULL, 0);
@
