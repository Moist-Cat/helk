# Formal grammar declaration for the HULK programming language
# Use "at sign" after every statement (yes, that includes comments).
# 
# Besides that, the syntax is like yacc's exept that we use
# the "dollar" symbol to separate the productions and the code.
#
# A few pointers:
# 
# - The code executes after the production is completely parsed
# - Each non-terminal returns a (ASTNode*) value called "node";
#    it defaults to NULL and you replace it with your own nodes.
# - There is a variable for each production
#    (named _{Production}; for example, if you have a non-terminal called
#    Expr, there will be a variable called _Expr in scope) already declared for you.
#    This variable contains the node (if it's a terminal) or the Token (it is not).
#    Use them to create complex structures
# - Don't forget to append "dollar" to the list of productions before writing code
# - Don't forget to write "at sign" after each statement

@

Program: StmtBlock $

    node = _StmtBlock;
    fprintf(stderr, "INFO - Created program block\n");

@

StmtBlock: Stmt SEMICOLON StmtBlockTail $

    // Collect all statements into a block
    if (_StmtBlockTail == NULL) {
        ASTNode** block = malloc(sizeof(ASTNode*) * 1);
        block[0] = _Stmt;
        node = create_ast_block(block, 1);
    } else {
        int count = _StmtBlockTail->block.stmt_count + 1;
        ASTNode** block = malloc(sizeof(ASTNode*) * count);
        block[0] = _Stmt;
        for (unsigned int i = 0; i < _StmtBlockTail->block.stmt_count; i++) {
            block[i+1] = _StmtBlockTail->block.statements[i];
        }
        node = create_ast_block(block, count);
        free(_StmtBlockTail->block.statements);
        free(_StmtBlockTail);
    }

@

StmtBlockTail: Stmt SEMICOLON StmtBlockTail $

    // Build linked list of statements
    if (_StmtBlockTail == NULL) {
        ASTNode** block = malloc(sizeof(ASTNode*) * 1);
        block[0] = _Stmt;
        node = create_ast_block(block, 1);
    } else {
        int count = _StmtBlockTail->block.stmt_count + 1;
        ASTNode** block = realloc(_StmtBlockTail->block.statements, sizeof(ASTNode*) * count);
        // Shift existing elements
        for (unsigned int i = count-1; i > 0; i--) {
            block[i] = block[i-1];
        }
        block[0] = _Stmt;
        node = create_ast_block(block, count);
    }

    | epsilon
@

Stmt: FunctionDef $
    node = _FunctionDef;

    | VariableDef $
    node = _VariableDef;

    | Expr $
    node = _Expr;
@

FunctionDef: FUNCTION IDENTIFIER LPAREN ParamList RPAREN ARROW Expr $

    node = create_ast_function_def(_IDENTIFIER.value, _Expr, _ParamList->param_list.params, _ParamList->param_list.count);
    fprintf(stderr, "INFO - Created function: %s\n", _IDENTIFIER.value);

@

ParamList: epsilon $
    node = create_ast_param_list(NULL, 0);

    | IDENTIFIER ParamListTail $
    
    char** params = malloc(sizeof(char*) * (_ParamListTail->param_list.count + 1));
    params[0] = _IDENTIFIER.value;
    for (unsigned int i = 0; i < _ParamListTail->param_list.count; i++) {
        params[i+1] = _ParamListTail->param_list.params[i];
    }
    node = create_ast_param_list(params, _ParamListTail->param_list.count + 1);
@

ParamListTail: COMMA IDENTIFIER ParamListTail $
    
    char** params = malloc(sizeof(char*) * (_ParamListTail->param_list.count + 1));
    params[0] = _IDENTIFIER.value;
    for (unsigned int i = 0; i < _ParamListTail->param_list.count; i++) {
        params[i+1] = _ParamListTail->param_list.params[i];
    }
    node = create_ast_param_list(params, _ParamListTail->param_list.count + 1);

    | epsilon $
        node = create_ast_param_list(NULL, 0);
@

VariableDef: LET IDENTIFIER EQUALS Expr $
    node = create_ast_variable_def(_IDENTIFIER.value, _Expr);
    fprintf(stderr, "INFO - Defined variable: %s\n", _IDENTIFIER.value);
@

Expr: Term ExprTail $

    if (_ExprTail == NULL) {
        node = _Term;
    } else {
        fprintf(stderr, "INFO - Completing Expr with type=%d\n", _Term->type);
        _ExprTail->binary_op.left = _Term;
        node = _ExprTail;
    }
@

ExprTail: PLUS Term ExprTail $
    if (_ExprTail == NULL) {
        node = create_ast_binary_op(NULL, _Term, OP_ADD);
    } else {
        node = create_ast_binary_op(
            NULL,
            create_ast_binary_op(_Term, _ExprTail, OP_ADD),
            OP_ADD
        );
    }

    | MINUS Term ExprTail $
    if (_ExprTail == NULL) {
        node = create_ast_binary_op(NULL, _Term, OP_SUB);
    } else {
        node = create_ast_binary_op(
            NULL,
            create_ast_binary_op(_Term, _ExprTail, OP_SUB),
            OP_ADD
        );
    }
    
    | epsilon
@

Term: Factor TermTail $
    if (_TermTail == NULL) {
        node = _Factor;
    } else {
        _TermTail->binary_op.left = _Factor;
        node = _TermTail;
    }
@

TermTail: MULTIPLY Factor TermTail $
    if (_TermTail == NULL) {
        node = create_ast_binary_op(NULL, _Factor, OP_MUL);
    } else {
        node = create_ast_binary_op(
            NULL,
            create_ast_binary_op(_Factor, _TermTail, OP_MUL),
            OP_MUL
        );
    }
    
    | DIVIDE Factor TermTail $
    if (_TermTail == NULL) {
        node = create_ast_binary_op(NULL, _Factor, OP_DIV);
    } else {
        node = create_ast_binary_op(
            NULL,
            create_ast_binary_op(_Factor, _TermTail, OP_DIV),
            OP_DIV
        );
    }
    
    | epsilon
@

Factor: NUMBER $
    node = create_ast_number(atoi(_NUMBER.value));

    | IDENTIFIER FactorTail $
    node = _FactorTail;
    if (node->type == AST_FUNCTION_CALL) {
        _FactorTail->function_call.name = _IDENTIFIER.value;
    }
    else {
        _FactorTail->variable.name = _IDENTIFIER.value;  // Set identifier name
    }

    | LPAREN Expr RPAREN $
    node = _Expr;
@

FactorTail: LPAREN ArgList RPAREN $
    node = create_ast_function_call("", _ArgList->block.statements, _ArgList->block.stmt_count);
    // Identifier will be set in parent Factor

    | epsilon $
        node = create_ast_variable("");
@

ArgList: epsilon $
    node = create_ast_block(NULL, 0);

    | Expr ArgListTail $
    if (_ArgListTail == NULL) {
        ASTNode** args = malloc(sizeof(ASTNode*) * (1));
        args[0] = _Expr;
        node = create_ast_block(args, 1);
    }
    else {
        ASTNode** args = malloc(sizeof(ASTNode*) * (_ArgListTail->block.stmt_count + 1));
        args[0] = _Expr;
        for (unsigned int i = 0; i < _ArgListTail->block.stmt_count; i++) {
            args[i+1] = _ArgListTail->block.statements[i];
        }
        node = create_ast_block(args, _ArgListTail->block.stmt_count + 1);
    }
@

ArgListTail: COMMA Expr ArgListTail $
    ASTNode** args = malloc(sizeof(ASTNode*) * (_ArgListTail->block.stmt_count + 1));
    args[0] = _Expr;
    for (unsigned int i = 0; i < _ArgListTail->block.stmt_count; i++) {
        args[i+1] = _ArgListTail->block.statements[i];
    }
    node = create_ast_block(args, _ArgListTail->block.stmt_count + 1);

    | epsilon $
        node = create_ast_block(NULL, 0);
@
